// Type definitions for bclient 0.1.3
// Project: https://github.com/bcoin-org/bcoin
// Definitions by: Joe Miyamoto <joemphilips@gmail.com>
/** Declaration file generated by dts-gen */
declare module 'bclient' {
  import { Client, BCurlClientOptions } from 'bcurl';
  import { Network, NetworkType, Mempool, primitives, wallet } from 'bcoin';
  import { BloomFilter } from 'bfilter';
  import { EventEmitter } from 'events';
  type AdditionalOpts = { network?: Network | NetworkType };
  type ClientOpts = string | (BCurlClientOptions & AdditionalOpts);
  export class NodeClient extends Client {
    constructor(options: ClientOpts);

    auth(): Promise<void>;

    execute(endpoint: string, method: string, params?: object): Promise<any>;
    execute(method: string, params?: object): Promise<any>;

    getMempool(): Promise<ReturnType<Mempool['getSnapshot']>>;
    getInfo(): Promise<any>;
    getCoinsByAddress(address: string): Promise<any>;
    getCoinsByAddresses(addresses: string[]): Promise<any>;
    getCoin(hash: string, index: number): Promise<any>;
    getTXByAddress(address: string): Promise<any>;
    getTXByAddresses(addresses: string[]): Promise<any>;
    getTX(hash: string): Promise<any>;
    getBlock(block: string | number): Promise<any>;
    broadcast(rawtx: string): Promise<any>;
    reset(height: number): Promise<any>;
    private watchChain(): Promise<any>;
    private watchMempool(): Promise<any>;
    getTip(): Promise<any>;
    getEntry(block: string): Promise<any>;
    getHashes(start?: number, end?: number): Promise<any>;
    send(tx: string): Promise<any>;
    setFilter(filter: BloomFilter): Promise<any>;
    addFilter(chunks: Buffer): Promise<any>;
    resetFilter(): Promise<any>;
    estimateFee(block?: number): Promise<any>;
    rescan(start: number | string): Promise<any>;
  }

  export interface Account {
    name: string;
    initialized: boolean;
    witness: boolean;
    watchOnly: boolean;
    type: 'pubkeyhash' | 'multisig';
    m: number;
    n: number;
    accountIndex: number;
    receiveDepth: number;
    changeDepth: number;
    nestedDepth: number;
    lookahead: number;
    receiveAddress: string;
    changeAddress: string;
    nestedAddress: null;
    accountKey: string;
    keys: ReadonlyArray<any>;
    balance: {
      tx: number;
      coin: number;
      unconfirmed: number;
      confirmed: number;
    };
  }

  interface createTXOptions {
    passphrase?: string;
    outputs?: primitives.OutputOptions[];
    rate?: number;
    maxFee?: number;
    selection?: string;
    smart?: boolean;
    account?: string;
    subtractFee?: boolean;
    subtractIndex?: number;
    depth?: number;
    confirmations?: number;
  }

  export class WalletClient extends Client {
    wallets: Map<any, any>;
    constructor(options: ClientOpts);
    open(): Promise<void>;
    close(): Promise<void>;
    auth(): Promise<void>;
    execute(endpoint: string, method: string, params?: object): Promise<any>;
    execute(method: string, params?: object): Promise<any>;
    private init(): void;
    /**
     * Open the client. Listen to following events
     * - tx
     * - confirmed
     * - unconfirmed
     * - conflict
     * - updated
     * - address
     * - balance
     */
    open(): Promise<void>;
    close(): Promise<void>;
    wallet(id: number, token?: string): Wallet;
    none(): Promise<void>;
    /**
     * Same with `join`
     * @param id
     * @param token
     */
    add(id: number, token: string): Promise<void>;
    /**
     * Join a wallet.
     * @param token
     */
    join(id: number, token: string): Promise<void>;
    leave(id: string): Promise<void>;
    rescan(height?: number): Promise<any>;
    resend(): Promise<any>;
    backup(path: string): Promise<any>;
    getWallets(): Promise<any>;
    createWallet(id: string, options?: any): Promise<any>;
    getHistory(id: string, account: string): Promise<any>;
    getCoins(id: string, account: string): Promise<any>;
    getPending(id: string, account: string): Promise<any>;
    getBalance(id: string, account: string): Promise<any>;
    getLast(id: string, account: string, limit: number): Promise<any>;
    getRange(id: string, account: string, options: object): Promise<any>;
    getTX(id: string, hash: string): Promise<any>;
    getBlocks(id: string): Promise<any>;
    getBlock(id: string): Promise<any>;
    getCoin(id: string, hash: string, index: number): Promise<any>;
    zap(id: string, account: string, age: number): Promise<any>;
    createTX(
      id: string,
      options: createTXOptions
    ): Promise<primitives.TXJsonResult>;
    send(id: string, options: { address: string; value: number }): Promise<any>;
    sign(id: string, options: object): Promise<primitives.TXJsonResult | null>;
    getInfo(id: string): Promise<any>;
    getAccounts(id: string): Promise<any>;
    getMaster(id: string): Promise<any>;
    getAccount(id: string, account: string): Promise<any>;
    createAccount(
      id: string,
      name: string,
      options: any
    ): Promise<wallet.AccountJson>;
    createAddress(
      id: string,
      account: string
    ): Promise<wallet.WalletKeyJsonOutput>;
    createChange(
      id: string,
      account: string
    ): Promise<wallet.WalletKeyJsonOutput>;
    createNested(
      id: string,
      account: string
    ): Promise<wallet.WalletKeyJsonOutput>;
    setPassphrase(
      id: string,
      passphrase: string,
      old?: string
    ): Promise<{ success: true }>;
    retoken(id: string, passphrase: string): Promise<string>;
    importPrivate(
      id: number | string,
      account: string,
      privateKey: string,
      passphrase?: string
    ): Promise<any>;
    importPublic(
      id: number | string,
      account: string,
      publicKey: string
    ): Promise<any>;
    importAddress(
      id: number | string,
      account: string,
      address: string
    ): Promise<any>;
    lockCoin(id: string, hash: string, index: number): Promise<any>;
    unlockCoin(id: string, hash: string, index: number): Promise<any>;
    getLocked(id: string): Promise<primitives.OutputJson[]>;
    lock(id: string): Promise<{ success: true }>;
    unlock(
      id: string,
      passphrase?: string,
      timeout?: number
    ): Promise<{ success: true }>;
    getKey(id: string, address?: string): Promise<wallet.WalletKeyJsonOutput>;
    getWIF(id: string, address?: string, passphrase?: string): Promise<string>;
    addSharedKey(
      id: string,
      account: string,
      accountKey: string
    ): Promise<{ success: true; addedKey: string }>;
    removeSharedKey(
      id: string,
      account: string,
      accountKey: string
    ): Promise<{ success: true; removedKey: string }>;
    resendWallet(id: string): Promise<{ success: true }>;
  }

  /**
   * Wallet instance.
   * Works as a proxy for the specific wallet on the server side.
   */
  class Wallet extends EventEmitter {
    parent: WalletClient;
    id: string | number;
    client: WalletClient;
    token?: string;
    constructor(parent: WalletClient, id: string | number, token: string);
    open(): Promise<void>;
    close(): Promise<void>;
    getHistory(account?: string): Promise<void>;
    getCoins(account?: string): ReturnType<WalletClient['getHistory']>;
    getPending(account?: string): ReturnType<WalletClient['getPending']>;
    getBalance(account?: string): ReturnType<WalletClient['getBalance']>;
    getLast(
      account?: string,
      limit?: number
    ): ReturnType<WalletClient['getLast']>;
    getRange(
      account?: string,
      options?: object
    ): ReturnType<WalletClient['getRange']>;
    getTX(account?: string, limit?: number): ReturnType<WalletClient['getTX']>;
    getBlocks(): ReturnType<WalletClient['getBlocks']>;
    getBlock(height: number): ReturnType<WalletClient['getBlock']>;
    getCoin(hash: string, index: number): ReturnType<WalletClient['getCoin']>;
    zap(account?: string, age?: number): ReturnType<WalletClient['zap']>;
    createTX(options?: createTXOptions): ReturnType<WalletClient['createTX']>;
    sign(
      id?: string,
      options?: { passphrase?: string; tx?: string }
    ): ReturnType<WalletClient['sign']>;
    getInfo(id?: string): ReturnType<WalletClient['getInfo']>;
    getAccounts(id?: string): ReturnType<WalletClient['getAccounts']>;
    getMaster(id?: string): ReturnType<WalletClient['getMaster']>;
    getAccount(account: string): ReturnType<WalletClient['getAccount']>;
    createAccount(
      name: string,
      options?: Partial<wallet.AccountOptions>
    ): ReturnType<WalletClient['createAccount']>;
    createAddress(
      id?: string,
      account?: string
    ): ReturnType<WalletClient['createAddress']>;
    createChange(
      id?: string,
      account?: string
    ): ReturnType<WalletClient['createChange']>;
    createNested(
      id?: string,
      account?: string
    ): ReturnType<WalletClient['createNested']>;
    setPassphrase(
      id?: string | Buffer,
      passphrase?: string,
      old?: string | Buffer
    ): ReturnType<WalletClient['setPassphrase']>;
    importPrivate(
      id: number | string,
      account: string,
      privateKey: string,
      passphrase: string
    ): ReturnType<WalletClient['importPrivate']>;
    importPublic(
      account: number | string,
      publicKey: string
    ): ReturnType<WalletClient['importPublic']>;
    importAddress(
      account: number | string,
      address: string
    ): ReturnType<WalletClient['importAddress']>;
    lockCoin(hash: string, index: number): ReturnType<WalletClient['lockCoin']>;
    unlockCoin(
      hash?: string,
      index?: number
    ): ReturnType<WalletClient['unlockCoin']>;
    getlocked(): ReturnType<WalletClient['getLocked']>;
    lock(): ReturnType<WalletClient['lock']>;
    unlock(
      passphrase?: string,
      timeout?: number
    ): ReturnType<WalletClient['unlock']>;

    getKey(address?: string): ReturnType<WalletClient['getKey']>;
    getWIF(
      address?: string,
      passphrase?: string
    ): ReturnType<WalletClient['getWIF']>;
    addSharedKey(
      account: string,
      accountKey: string
    ): ReturnType<WalletClient['addSharedKey']>;
    removeSharedKey(
      account: string,
      accountKey: string
    ): ReturnType<WalletClient['removeSharedKey']>;
    resendWallet(): ReturnType<WalletClient['resendWallet']>;
  }
}
